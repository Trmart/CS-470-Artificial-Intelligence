# --------
# @file     agent.py
# @author   Taylor Martin
# @date     May 2023
# @class    CS 470 Artificial Intelligence
#
# @brief    This file contains the agent class. For traversing the map generated by the environment class. Utilizes various AI pathfinding algorithms for traversal.
# --------------------

from environment import Environment
import math

class Agent:
    
    """
    Agent Class 
    """

    def __init__(self):
        """
        Constructor
        """
        self.env = Environment()
        self.path = {}
        self.path_cost = 0
        self.path_length = 0
        self.closed_list = set()
        self.open_list = []

    def is_goal(self, state):
        """
        Check if state is goal
        """
        if state == self.env.get_goal():
            return True
        else:
            return False
    
    def is_not_explored(self, state):
        """
        Check if state is not explored
        """
        return (state not in self.open_list and state not in self.closed_list)
        
    def record_agent_path(self, parent, child):
        """
        Record agent path
        """
        self.path[child] = parent

    def get_path(self):
        """
        Get path
        """
        path = [self.env.get_goal()]
        
        while path[-1] != self.env.get_start():
            path.append(self.path[path[-1]])
        path.reverse()
        
        return tuple(path)
    
    def print_path(self):
        """
        Print path
        """
        for y in range(0,self.env.get_map_height()):
            for x in range(0,self.env.get_map_width()):
                if (x,y) == self.env.get_start():
                    print("S", end="")
                elif (x,y) == self.env.get_goal():
                    print("G", end="")
                elif (x,y) in self.get_path():
                    print("*", end="")
                elif (x,y) in self.open_list:
                    print("#", end="")
                else:
                    print(self.env.get_map()[y][x], end="")
            print()

    def print_explored(self):
        """
        Print path
        """
        for y in range(0,self.env.get_map_height()):
            for x in range(0,self.env.get_map_width()):
                if (x,y) == self.env.get_start():
                    print("S", end="")
                elif (x,y) == self.env.get_goal():
                    print("G", end="")
                elif (x,y) in self.get_path():
                    print("*", end="")
                elif (x,y) in self.closed_list:
                    print("$", end="")
                else:
                    print(self.env.get_map()[y][x], end="")
            print()
    
    def save_path_to_file(self, output_file):
        """
        Save the agent path to a file.
        """

        with open(output_file, 'w') as file:
            file.write("*******************BFS Agent Path***********************\n")
            file.write("Map Size: " + str(self.env.get_map_size()) + "\n")
            file.write("Map Width: " + str(self.env.get_map_width()) + "\n" + "Map Hight: " + str(self.env.get_map_height()) + "\n")
            file.write("Starting Point: " + str(self.env.get_start()) + "\n")
            file.write("Goal Point: " + str(self.env.get_goal()) + "\n")
            
            file.write(f'\nState Costs:\n\n')
            file.write(f'{"Character:":15}{"Area:":10}{"Cost:":4}\n')
        
            i = 0
            for key, value in self.env.get_costs().items():
                file.write(f'{key:15}{self.env.area_names[i]:10}{value:4}\n')
                i += 1

            file.write("\n\nAgent Symbol Legend:\n")
            file.write("S = Start\n")
            file.write("G = Goal\n")
            file.write("* = Path\n")
            file.write("# = Open List\n")
            
            path = self.get_path()
            print("\n\nAgent Path: " + str(path))

            print("\n\nNumber of Nodes Explored: " + str(self.closed_list.__len__()))

            #path cost is correct
            print("\n\nPath Cost: " + str(self.path_cost))

            # I think path length is correct. there are 27 nodes in the path list
            print("\n\nPath Length: " + str(self.path_length))
            file.write("\nPath: \n")
            

            for y in range(0,self.env.get_map_height()):
                for x in range(0,self.env.get_map_width()):
                    if (x,y) == self.env.get_start():
                        file.write("S")
                    elif (x,y) == self.env.get_goal():
                        file.write("G")
                    elif (x,y) in self.get_path():
                        file.write("*")
                    elif (x,y) in self.open_list:
                        file.write("#")
                    else:
                        file.write(self.env.get_map()[y][x])
                file.write('\n')

            
            file.close()
    
    def save_explored_to_file(self, output_file):
        """
        save the explored path to file
        """

        with open(output_file, 'w') as file:
            
            file.write("*******************BFS Agent Nodes Explored***********************\n")
            file.write("Map Size: " + str(self.env.get_map_size()) + "\n")
            file.write("Map Width: " + str(self.env.get_map_width()) + "\n" + "Map Hight: " + str(self.env.get_map_height()) + "\n")
            file.write("Starting Point: " + str(self.env.get_start()) + "\n")
            file.write("Goal Point: " + str(self.env.get_goal()) + "\n")
            
            file.write(f'\nState Costs:\n\n')
            file.write(f'{"Character:":15}{"Area:":10}{"Cost:":4}\n')
        
            i = 0
            for key, value in self.env.get_costs().items():
                file.write(f'{key:15}{self.env.area_names[i]:10}{value:4}\n')
                i += 1
            
            file.write("\n\nAgent Symbol Legend:\n")
            file.write("S = Start\n")
            file.write("G = Goal\n")
            file.write("* = Path\n")
            file.write("$ = Closed List\n")

            path = self.get_path()
            print("\n\nExplored Nodes: " + str(path))

            print("\n\nNumber of Nodes Explored: " + str(self.closed_list.__len__()))

            #path cost is correct
            print("\n\nPath Cost: " + str(self.path_cost))

            # I think path length is correct. there are 27 nodes in the path list
            print("\n\nPath Length: " + str(self.path_length))
            file.write("\nPath: \n")
            

            for y in range(0,self.env.get_map_height()):
                for x in range(0,self.env.get_map_width()):
                    if (x,y) == self.env.get_start():
                        file.write("S")
                    elif (x,y) == self.env.get_goal():
                        file.write("G")
                    elif (x,y) in self.get_path():
                        file.write("*")
                    elif (x,y) in self.closed_list:
                        file.write("$")
                    else:
                        file.write(self.env.get_map()[y][x])
                file.write('\n')
            
        file.close()
    
    def get_state_cost(self, state):
        """
        Get state cost
        """
        x,y = state
        return self.env.get_costs()[self.env.get_map()[y][x]]
    
    def add_to_openlist(self, state, cost = None):
        """
        Add to open list
        """
        if cost is not None:
            self.open_list.append([state, cost])
        else:
            self.open_list.append(state)

    def add_to_closedlist(self, state):
        """
        Add to closed list
        """
        self.closed_list.add(state)
    
    def remove_from_openlist(self, index):
        """
        Remove from open list
        """
        self.open_list.pop(self.open_list.index(index))
    
    def remove_from_closedlist(self, state):
        """
        Remove from closed list
        """
        try:
            self.closed_list.remove(state)
        except KeyError:
            pass
    
    def get_next_open_list_head(self):
        """
        Get next open list head
        """
        return self.open_list.pop(0)
    
    def get_next_open_list_tail(self):
        """
        Get next open list tail
        """
        return self.open_list.pop()
    
    def is_valid_state(self, state):
        """
        Check if state is valid
        """ 
        x, y = state
        # print("x: " + str(x) + " y: " + str(y))
        
        if (x >= 0 and 
            y >= 0 and 
            x < self.env.get_map_width() and 
            y < self.env.get_map_height() and 
            self.env.get_map()[y][x] != 'W'):
            return True
        else:
            return False
    
    def expand_node(self, state):
        """
        Expand node
        """
        result = []

        x, y = state

        neighbors = (
                        (x, y-1),
                        (x, y+1),
                        (x+1, y),
                        (x-1, y)
                    )
        
        for neighbor in neighbors:
            if self.is_valid_state(neighbor):
                result.append(neighbor)
        
        return result

    def euclidean_distance(self, state):
        """
        Euclidean distance / Straight line distance
        """
        x1, y1 = state
        x2, y2 = self.env.get_goal()
        
        return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
    

    def manhattan_distance(self, state):
        """
        Manhattan distance / Taxicab distance
        """
        x1, y1 = state
        x2, y2 = self.env.get_goal()
        
        return (abs(x1 - x2) + abs(y1 - y2))

    def breadth_first_search(self):
        """
        Breadth First Search
        """
        self.add_to_openlist(self.env.get_start())
        # print(self.open_list)
        
        while self.open_list:
            
            parent = self.get_next_open_list_head()
            # print(parent)
            
            if self.is_goal(parent):
                for state in self.get_path():
                    self.path_cost += self.get_state_cost(state)
                self.path_length = len(self.get_path())
                return parent
            
            for child in self.expand_node(parent):
                if self.is_not_explored(child):
                    self.record_agent_path(parent, child)
                    self.add_to_openlist(child)
            self.add_to_closedlist(parent)
        
        return None

    def lowest_cost_search(self):
        """
        Lowest Cost Search
        """
    
    
    def greedy_best_first_search(self):

        """
        Greedy Best First Search
        """
    
    
    def a_star_search(self):
        """
        A* Search
        """
    

    # After a successful search the program should do the following:

    # Draw the path on the map.
    # Denote all of the explored squares on the map.
    # Denote the current open/frige list.
    # Report the length of the path found.
    # Report the cost of the path found.
    # This does not require a graphical output (although that's probably best). You could draw a text version of the map (as in the sample file) and underline explored squares, bold open squares, and highlight squares on the successful path.
    # Algorithms: You will need to test the following algorithms:

    # Breadth first.
    # Lowest cost.
    # Greedy best first
    # A* with at least two different heuristics.
    # Experiments: For each algorithm you will need to do the following:

    # Show that the algorithm works. In particular you should show, with an actual figure, both the cells explored by the algorithm and the route that the algorithm finds. Make sure that the figure clearly shows that the algorithm works. For example, if there is a mountain range that impedes movement show that the algorithm searches for paths around it.